/**
 * Location API
 * Geolocation, Geocoding and Maps
 *
 * OpenAPI spec version: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef ModelFactory_H_
#define ModelFactory_H_

#include "OAIObject.h"

#include "OAIAddress_details_schema.h"
#include "OAIAddress_schema.h"
#include "OAIAll_schema.h"
#include "OAIBalance_response_schema.h"
#include "OAIBt_schema.h"
#include "OAICell_schema.h"
#include "OAIError_schema.h"
#include "OAIFallback_schema.h"
#include "OAIGeolocation_address_schema.h"
#include "OAIGeolocation_error_schema.h"
#include "OAIGeolocation_response_schema.h"
#include "OAIGeolocation_schema.h"
#include "OAIIpf_schema.h"
#include "OAILacf_schema.h"
#include "OAIRadio_schema.h"
#include "OAIReverse_response_schema.h"
#include "OAIScf_schema.h"
#include "OAISearch_response_schema.h"
#include "OAITimezone_response_schema.h"
#include "OAITimezone_schema.h"
#include "OAIWifi_schema.h"

namespace OpenAPI {

  inline void* create(QString type) {
    if(QString("OAIAddress_details_schema").compare(type) == 0) {
      return new OAIAddress_details_schema();
    }
    if(QString("OAIAddress_schema").compare(type) == 0) {
      return new OAIAddress_schema();
    }
    if(QString("OAIAll_schema").compare(type) == 0) {
      return new OAIAll_schema();
    }
    if(QString("OAIBalance_response_schema").compare(type) == 0) {
      return new OAIBalance_response_schema();
    }
    if(QString("OAIBt_schema").compare(type) == 0) {
      return new OAIBt_schema();
    }
    if(QString("OAICell_schema").compare(type) == 0) {
      return new OAICell_schema();
    }
    if(QString("OAIError_schema").compare(type) == 0) {
      return new OAIError_schema();
    }
    if(QString("OAIFallback_schema").compare(type) == 0) {
      return new OAIFallback_schema();
    }
    if(QString("OAIGeolocation_address_schema").compare(type) == 0) {
      return new OAIGeolocation_address_schema();
    }
    if(QString("OAIGeolocation_error_schema").compare(type) == 0) {
      return new OAIGeolocation_error_schema();
    }
    if(QString("OAIGeolocation_response_schema").compare(type) == 0) {
      return new OAIGeolocation_response_schema();
    }
    if(QString("OAIGeolocation_schema").compare(type) == 0) {
      return new OAIGeolocation_schema();
    }
    if(QString("OAIIpf_schema").compare(type) == 0) {
      return new OAIIpf_schema();
    }
    if(QString("OAILacf_schema").compare(type) == 0) {
      return new OAILacf_schema();
    }
    if(QString("OAIRadio_schema").compare(type) == 0) {
      return new OAIRadio_schema();
    }
    if(QString("OAIReverse_response_schema").compare(type) == 0) {
      return new OAIReverse_response_schema();
    }
    if(QString("OAIScf_schema").compare(type) == 0) {
      return new OAIScf_schema();
    }
    if(QString("OAISearch_response_schema").compare(type) == 0) {
      return new OAISearch_response_schema();
    }
    if(QString("OAITimezone_response_schema").compare(type) == 0) {
      return new OAITimezone_response_schema();
    }
    if(QString("OAITimezone_schema").compare(type) == 0) {
      return new OAITimezone_schema();
    }
    if(QString("OAIWifi_schema").compare(type) == 0) {
      return new OAIWifi_schema();
    }
    
    return nullptr;
  }

  inline void* create(QString json, QString type) {
    if(type.startsWith("QString")) {
      return new QString();
    }    
    auto val = static_cast<OAIObject*>(create(type));
    if(val != nullptr) {
      return val->fromJson(json);
    }
    return nullptr;
  }

}

#endif /* ModelFactory_H_ */
