/* 
 * Location API
 *
 * Geolocation, Geocoding and Maps
 *
 * OpenAPI spec version: 2.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */

/// CellSchema : You can send 1 to 7 cell ID objects. If your device supports scanning for more than 7 cell objects, reach out to us and we’ll increase this limit on your account. The first cell object has to be that of the serving cell, i.e. the tower the device is connected to. The others are neighbouring cell objects that are visible to the device. Except lac and cid all other parameters mentioned below are optional. Parameters vary depending on the radio type. Supported radio types and their corresponding parameters are

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct CellSchema {
  /// the Location Area Code of your operator’s network.
  #[serde(rename = "lac")]
  lac: Option<i64>,
  /// Cell ID
  #[serde(rename = "cid")]
  cid: Option<i64>,
  #[serde(rename = "radio")]
  radio: Option<::models::RadioSchema>,
  /// \"Mobile Country Code of your operator’s network represented by an integer (Optional). Range: 0 to 999.\"
  #[serde(rename = "mcc")]
  mcc: Option<i64>,
  /// Mobile Network Code of your operator’s network represented by an integer (Optional). Range: 0 to 999. On CDMA, provide the System ID or SID, with range: 1 to 32767.
  #[serde(rename = "mnc")]
  mnc: Option<i64>,
  /// Signal Strength (RSSI)
  #[serde(rename = "signal")]
  signal: Option<i64>,
  /// Primary Scrambling Code
  #[serde(rename = "psc")]
  psc: Option<i64>,
  /// Arbitrary Strength Unit
  #[serde(rename = "asu")]
  asu: Option<i64>,
  /// Timing Advance
  #[serde(rename = "ta")]
  ta: Option<i64>
}

impl CellSchema {
  /// You can send 1 to 7 cell ID objects. If your device supports scanning for more than 7 cell objects, reach out to us and we’ll increase this limit on your account. The first cell object has to be that of the serving cell, i.e. the tower the device is connected to. The others are neighbouring cell objects that are visible to the device. Except lac and cid all other parameters mentioned below are optional. Parameters vary depending on the radio type. Supported radio types and their corresponding parameters are
  pub fn new() -> CellSchema {
    CellSchema {
      lac: None,
      cid: None,
      radio: None,
      mcc: None,
      mnc: None,
      signal: None,
      psc: None,
      asu: None,
      ta: None
    }
  }

  pub fn set_lac(&mut self, lac: i64) {
    self.lac = Some(lac);
  }

  pub fn with_lac(mut self, lac: i64) -> CellSchema {
    self.lac = Some(lac);
    self
  }

  pub fn lac(&self) -> Option<&i64> {
    self.lac.as_ref()
  }

  pub fn reset_lac(&mut self) {
    self.lac = None;
  }

  pub fn set_cid(&mut self, cid: i64) {
    self.cid = Some(cid);
  }

  pub fn with_cid(mut self, cid: i64) -> CellSchema {
    self.cid = Some(cid);
    self
  }

  pub fn cid(&self) -> Option<&i64> {
    self.cid.as_ref()
  }

  pub fn reset_cid(&mut self) {
    self.cid = None;
  }

  pub fn set_radio(&mut self, radio: ::models::RadioSchema) {
    self.radio = Some(radio);
  }

  pub fn with_radio(mut self, radio: ::models::RadioSchema) -> CellSchema {
    self.radio = Some(radio);
    self
  }

  pub fn radio(&self) -> Option<&::models::RadioSchema> {
    self.radio.as_ref()
  }

  pub fn reset_radio(&mut self) {
    self.radio = None;
  }

  pub fn set_mcc(&mut self, mcc: i64) {
    self.mcc = Some(mcc);
  }

  pub fn with_mcc(mut self, mcc: i64) -> CellSchema {
    self.mcc = Some(mcc);
    self
  }

  pub fn mcc(&self) -> Option<&i64> {
    self.mcc.as_ref()
  }

  pub fn reset_mcc(&mut self) {
    self.mcc = None;
  }

  pub fn set_mnc(&mut self, mnc: i64) {
    self.mnc = Some(mnc);
  }

  pub fn with_mnc(mut self, mnc: i64) -> CellSchema {
    self.mnc = Some(mnc);
    self
  }

  pub fn mnc(&self) -> Option<&i64> {
    self.mnc.as_ref()
  }

  pub fn reset_mnc(&mut self) {
    self.mnc = None;
  }

  pub fn set_signal(&mut self, signal: i64) {
    self.signal = Some(signal);
  }

  pub fn with_signal(mut self, signal: i64) -> CellSchema {
    self.signal = Some(signal);
    self
  }

  pub fn signal(&self) -> Option<&i64> {
    self.signal.as_ref()
  }

  pub fn reset_signal(&mut self) {
    self.signal = None;
  }

  pub fn set_psc(&mut self, psc: i64) {
    self.psc = Some(psc);
  }

  pub fn with_psc(mut self, psc: i64) -> CellSchema {
    self.psc = Some(psc);
    self
  }

  pub fn psc(&self) -> Option<&i64> {
    self.psc.as_ref()
  }

  pub fn reset_psc(&mut self) {
    self.psc = None;
  }

  pub fn set_asu(&mut self, asu: i64) {
    self.asu = Some(asu);
  }

  pub fn with_asu(mut self, asu: i64) -> CellSchema {
    self.asu = Some(asu);
    self
  }

  pub fn asu(&self) -> Option<&i64> {
    self.asu.as_ref()
  }

  pub fn reset_asu(&mut self) {
    self.asu = None;
  }

  pub fn set_ta(&mut self, ta: i64) {
    self.ta = Some(ta);
  }

  pub fn with_ta(mut self, ta: i64) -> CellSchema {
    self.ta = Some(ta);
    self
  }

  pub fn ta(&self) -> Option<&i64> {
    self.ta.as_ref()
  }

  pub fn reset_ta(&mut self) {
    self.ta = None;
  }

}



