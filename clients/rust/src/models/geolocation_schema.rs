/* 
 * Location API
 *
 * Geolocation, Geocoding and Maps
 *
 * OpenAPI spec version: 2.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct GeolocationSchema {
  #[serde(rename = "token")]
  token: Option<String>,
  /// ID of the device, in case you are in a per-device plan. This could be any unique string such as an IMEI, IMSI, phone number or a hash of any of the previous values, etc. Maximum accepted length is 20 chars, and values should only be alphanumeric (a-z, 0-9)
  #[serde(rename = "id")]
  id: Option<String>,
  #[serde(rename = "radio")]
  radio: Option<::models::RadioSchema>,
  /// \"Mobile Country Code of your operator’s network represented by an integer (Optional). Range: 0 to 999.\"
  #[serde(rename = "mcc")]
  mcc: Option<i64>,
  /// Mobile Network Code of your operator’s network represented by an integer (Optional). Range: 0 to 999. On CDMA, provide the System ID or SID, with range: 1 to 32767.
  #[serde(rename = "mnc")]
  mnc: Option<i64>,
  /// An array of cell ID objects
  #[serde(rename = "cells")]
  cells: Option<Vec<::models::CellSchema>>,
  /// An array of WiFi objects visible to the device.
  #[serde(rename = "wifi")]
  wifi: Option<Vec<::models::WifiSchema>>,
  #[serde(rename = "fallbacks")]
  fallbacks: Option<::models::FallbackSchema>,
  #[serde(rename = "address")]
  address: Option<::models::GeolocationAddressSchema>,
  /// IP address of device.
  #[serde(rename = "ip")]
  ip: Option<String>,
  #[serde(rename = "bt")]
  bt: Option<::models::BtSchema>
}

impl GeolocationSchema {
  pub fn new() -> GeolocationSchema {
    GeolocationSchema {
      token: None,
      id: None,
      radio: None,
      mcc: None,
      mnc: None,
      cells: None,
      wifi: None,
      fallbacks: None,
      address: None,
      ip: None,
      bt: None
    }
  }

  pub fn set_token(&mut self, token: String) {
    self.token = Some(token);
  }

  pub fn with_token(mut self, token: String) -> GeolocationSchema {
    self.token = Some(token);
    self
  }

  pub fn token(&self) -> Option<&String> {
    self.token.as_ref()
  }

  pub fn reset_token(&mut self) {
    self.token = None;
  }

  pub fn set_id(&mut self, id: String) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: String) -> GeolocationSchema {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&String> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_radio(&mut self, radio: ::models::RadioSchema) {
    self.radio = Some(radio);
  }

  pub fn with_radio(mut self, radio: ::models::RadioSchema) -> GeolocationSchema {
    self.radio = Some(radio);
    self
  }

  pub fn radio(&self) -> Option<&::models::RadioSchema> {
    self.radio.as_ref()
  }

  pub fn reset_radio(&mut self) {
    self.radio = None;
  }

  pub fn set_mcc(&mut self, mcc: i64) {
    self.mcc = Some(mcc);
  }

  pub fn with_mcc(mut self, mcc: i64) -> GeolocationSchema {
    self.mcc = Some(mcc);
    self
  }

  pub fn mcc(&self) -> Option<&i64> {
    self.mcc.as_ref()
  }

  pub fn reset_mcc(&mut self) {
    self.mcc = None;
  }

  pub fn set_mnc(&mut self, mnc: i64) {
    self.mnc = Some(mnc);
  }

  pub fn with_mnc(mut self, mnc: i64) -> GeolocationSchema {
    self.mnc = Some(mnc);
    self
  }

  pub fn mnc(&self) -> Option<&i64> {
    self.mnc.as_ref()
  }

  pub fn reset_mnc(&mut self) {
    self.mnc = None;
  }

  pub fn set_cells(&mut self, cells: Vec<::models::CellSchema>) {
    self.cells = Some(cells);
  }

  pub fn with_cells(mut self, cells: Vec<::models::CellSchema>) -> GeolocationSchema {
    self.cells = Some(cells);
    self
  }

  pub fn cells(&self) -> Option<&Vec<::models::CellSchema>> {
    self.cells.as_ref()
  }

  pub fn reset_cells(&mut self) {
    self.cells = None;
  }

  pub fn set_wifi(&mut self, wifi: Vec<::models::WifiSchema>) {
    self.wifi = Some(wifi);
  }

  pub fn with_wifi(mut self, wifi: Vec<::models::WifiSchema>) -> GeolocationSchema {
    self.wifi = Some(wifi);
    self
  }

  pub fn wifi(&self) -> Option<&Vec<::models::WifiSchema>> {
    self.wifi.as_ref()
  }

  pub fn reset_wifi(&mut self) {
    self.wifi = None;
  }

  pub fn set_fallbacks(&mut self, fallbacks: ::models::FallbackSchema) {
    self.fallbacks = Some(fallbacks);
  }

  pub fn with_fallbacks(mut self, fallbacks: ::models::FallbackSchema) -> GeolocationSchema {
    self.fallbacks = Some(fallbacks);
    self
  }

  pub fn fallbacks(&self) -> Option<&::models::FallbackSchema> {
    self.fallbacks.as_ref()
  }

  pub fn reset_fallbacks(&mut self) {
    self.fallbacks = None;
  }

  pub fn set_address(&mut self, address: ::models::GeolocationAddressSchema) {
    self.address = Some(address);
  }

  pub fn with_address(mut self, address: ::models::GeolocationAddressSchema) -> GeolocationSchema {
    self.address = Some(address);
    self
  }

  pub fn address(&self) -> Option<&::models::GeolocationAddressSchema> {
    self.address.as_ref()
  }

  pub fn reset_address(&mut self) {
    self.address = None;
  }

  pub fn set_ip(&mut self, ip: String) {
    self.ip = Some(ip);
  }

  pub fn with_ip(mut self, ip: String) -> GeolocationSchema {
    self.ip = Some(ip);
    self
  }

  pub fn ip(&self) -> Option<&String> {
    self.ip.as_ref()
  }

  pub fn reset_ip(&mut self) {
    self.ip = None;
  }

  pub fn set_bt(&mut self, bt: ::models::BtSchema) {
    self.bt = Some(bt);
  }

  pub fn with_bt(mut self, bt: ::models::BtSchema) -> GeolocationSchema {
    self.bt = Some(bt);
    self
  }

  pub fn bt(&self) -> Option<&::models::BtSchema> {
    self.bt.as_ref()
  }

  pub fn reset_bt(&mut self) {
    self.bt = None;
  }

}



