/* 
 * Location API
 *
 * Geolocation, Geocoding and Maps
 *
 * OpenAPI spec version: 2.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */

/// WifiSchema : You can send a minimum of 2 and a maximum of 15 WiFi objects in 1 request. If WiFi is not available, wifi object can be omitted all together. In accordance with our industry’s privacy standards we require a minimum of 2 valid nearby Access Points to be sent. If your use-case allows only 1 AP, reach out to us.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct WifiSchema {
  /// Basic Service Set Identifier or MAC address of the Access Point. Typical format of a MAC address is xx-xx-xx-xx-xx-xx. However, the delimiter can be any of these when sent to the API: : or - or .
  #[serde(rename = "bssid")]
  bssid: Option<String>,
  /// Channel the WiFi network is operating in (optional)
  #[serde(rename = "channel")]
  channel: Option<i64>,
  /// Frequency the WiFi network is operating in (MHz) (optional)
  #[serde(rename = "frequency")]
  frequency: Option<i64>,
  /// Signal Strength (RSSI)
  #[serde(rename = "signal")]
  signal: Option<i64>,
  /// The current signal to noise ratio, measured in dB (optional)
  #[serde(rename = "signalToNoiseRatio")]
  signal_to_noise_ratio: Option<i64>
}

impl WifiSchema {
  /// You can send a minimum of 2 and a maximum of 15 WiFi objects in 1 request. If WiFi is not available, wifi object can be omitted all together. In accordance with our industry’s privacy standards we require a minimum of 2 valid nearby Access Points to be sent. If your use-case allows only 1 AP, reach out to us.
  pub fn new() -> WifiSchema {
    WifiSchema {
      bssid: None,
      channel: None,
      frequency: None,
      signal: None,
      signal_to_noise_ratio: None
    }
  }

  pub fn set_bssid(&mut self, bssid: String) {
    self.bssid = Some(bssid);
  }

  pub fn with_bssid(mut self, bssid: String) -> WifiSchema {
    self.bssid = Some(bssid);
    self
  }

  pub fn bssid(&self) -> Option<&String> {
    self.bssid.as_ref()
  }

  pub fn reset_bssid(&mut self) {
    self.bssid = None;
  }

  pub fn set_channel(&mut self, channel: i64) {
    self.channel = Some(channel);
  }

  pub fn with_channel(mut self, channel: i64) -> WifiSchema {
    self.channel = Some(channel);
    self
  }

  pub fn channel(&self) -> Option<&i64> {
    self.channel.as_ref()
  }

  pub fn reset_channel(&mut self) {
    self.channel = None;
  }

  pub fn set_frequency(&mut self, frequency: i64) {
    self.frequency = Some(frequency);
  }

  pub fn with_frequency(mut self, frequency: i64) -> WifiSchema {
    self.frequency = Some(frequency);
    self
  }

  pub fn frequency(&self) -> Option<&i64> {
    self.frequency.as_ref()
  }

  pub fn reset_frequency(&mut self) {
    self.frequency = None;
  }

  pub fn set_signal(&mut self, signal: i64) {
    self.signal = Some(signal);
  }

  pub fn with_signal(mut self, signal: i64) -> WifiSchema {
    self.signal = Some(signal);
    self
  }

  pub fn signal(&self) -> Option<&i64> {
    self.signal.as_ref()
  }

  pub fn reset_signal(&mut self) {
    self.signal = None;
  }

  pub fn set_signal_to_noise_ratio(&mut self, signal_to_noise_ratio: i64) {
    self.signal_to_noise_ratio = Some(signal_to_noise_ratio);
  }

  pub fn with_signal_to_noise_ratio(mut self, signal_to_noise_ratio: i64) -> WifiSchema {
    self.signal_to_noise_ratio = Some(signal_to_noise_ratio);
    self
  }

  pub fn signal_to_noise_ratio(&self) -> Option<&i64> {
    self.signal_to_noise_ratio.as_ref()
  }

  pub fn reset_signal_to_noise_ratio(&mut self) {
    self.signal_to_noise_ratio = None;
  }

}



